{
  "page": 41,
  "title": "Memory Content and Management Strategies",
  "content": "<div class=\"article-header\">\n                        <div class=\"section-label\">Section 5.3.2 &middot; Memory (continued)</div>\n                        <h1>Memory Content and Management Strategies</h1>\n                    </div>\n                    <div class=\"original-content\">\n                        <h3>Memory Content: Semantic, Task, and Cognitive-Phase Decomposition</h3>\n                        <p>Different content decomposition strategies suit different task characteristics, and the choice of content structure fundamentally shapes how agents interact with memory. MIRIX [328] pioneered semantic decomposition by defining six specialized memory types (Core, Episodic, Semantic, Procedural, Resource, Knowledge Vault) managed by distinct agents, achieving a 35% accuracy gain on multimodal QA tasks while reducing storage through flexible routing.</p>\n                        <p>Building on this modular principle, LEGOMem [428] instead employs task-based decomposition, breaking execution traces into reusable memory units flexibly assigned to either central planners or specialist task agents. This design shows that orchestrator memory improves task decomposition and delegation, while agent memory enhances subtask execution, effectively narrowing performance gaps between small and large LLM teams.</p>\n                        <p>Recently, MAPLE introduced Cognitive-phase Decomposition [145], using specialized agents (Solver, Checker, Reflector, Archiver) to enable systematic error detection and plan repair cycles. The Reflector diagnoses errors after each episode, and the Archiver stores refined plans to avoid repeated mistakes, supporting feedback-driven learning.</p>\n                        <h3>Memory Management Strategies</h3>\n                        <p>Effective long-term memory requires active management balancing relevance, efficiency, and coherence through different approaches that trade off simplicity against sophistication. Lyte Agents [429] pioneered the forgetting-based approach using Summarize-and-Forget mechanisms to regularly compress memory, retaining only critical context. This strategy is suitable when storage is severely constrained, though it risks losing nuanced details for edge cases.</p>\n                        <p>To improve upon simple forgetting, AGENTGB [430] introduced more sophisticated management by organizing procedural traces into structured (entity, action, observation) triples and learning pattern abstractions reusable across tasks. Agents collaborate to retrieve, update, and reason over memory segments, enabling generalization without explicit retraining while central coordination ensures long-term consistency for scalable embodied planning.</p>\n                        <h3>Discussions</h3>\n                        <p>Despite substantial progress, multi-agent memory systems remain largely unexplored with respect to post-training and model adaptation. Current approaches focus primarily on memory organization and retrieval for pre-trained models, with little investigation into how multiple agents can jointly optimize their memories through post-training procedures such as reinforcement learning or supervised fine-tuning.</p>\n                    </div>\n                    <div class=\"analysis-section\">\n                        <h3>Analysis & Explanation</h3>\n                        <div class=\"analysis-block\">\n                            <h4>Memory Decomposition Approaches</h4>\n                            <div class=\"analysis-item\">\n                                <h5>Semantic vs Task-Based</h5>\n                                <p><strong>Semantic:</strong> Organizes by knowledge type (episodic, procedural, etc.) - good for diverse queries</p>\n                                <p><strong>Task-Based:</strong> Organizes by execution traces - good for similar recurring tasks</p>\n                                <p><strong>Cognitive-Phase:</strong> Organizes by reasoning stage - good for error detection and learning</p>\n                            </div>\n                        </div>\n                    </div>"
}