{
  "page": 47,
  "title": "Memory and Collective Multi-Agent Reasoning in Math/Code",
  "content": "<div class=\"article-header\">\n                        <div class=\"section-label\">Section 6.1.2-6.1.3 &middot; Self-Evolving & Collective</div>\n                        <h1>Memory and Collective Reasoning in Math/Code</h1>\n                    </div>\n                    <div class=\"original-content\">\n                        <h3>Memory</h3>\n                        <p>Memory provides agents with a mechanism for retaining and leveraging information from earlier reasoning steps, allowing them to maintain consistency, improve intermediate states, and improve their performance over extended problem-solving horizons. While few systems introduce an explicit memory module, many mathematical agents rely on forms of persistent state that can be viewed as implicit memory.</p>\n                        <p>Interactive evaluation frameworks [486] maintain conversational and problem-state context across multiple turns, allowing models to build upon earlier partial derivations. Formal-theorem-proving agents [473] operate over evolving proof states in Lean, which accumulate tactics, subgoals, and intermediate lemmas, functioning as structured persistent information.</p>\n                        <p>In code agents, memory increasingly takes the form of explicit structures that maintain coherence over long-horizon generation. Several systems construct shared or structured workspaces: Self-Collaboration [492] introduces a blackboard memory for storing task descriptions, intermediate drafts, and revision records, enabling agents to coordinate through a common representation.</p>\n                        <h3>6.1.3. Collective Multi-agent Reasoning</h3>\n                        <p>To address the growing complexity of tasks in mathematical discovery and code generation, recent systems increasingly rely on multi-agent or modular designs that decompose problems into cooperating specialized components. Mathematical discovery frameworks often organize reasoning into explicitly defined multi-agent or multi-component workflows that collaborate to explore and validate mathematical ideas.</p>\n                        <p>Multi-agent systems for code generation have progressed from simple role-based pipelines to adaptive, collaborative frameworks capable of handling long-horizon software development. Early approaches such as Self-Collaboration [492] and AgentCoder [495] decompose tasks into sequential roles, while hierarchical designs like PairCoder [496] and FlowGen [497] introduce an architecture in which high-level agents handle planning and lower-level agents carry out concrete implementation.</p>\n                    </div>\n                    <div class=\"analysis-section\">\n                        <h3>Analysis & Explanation</h3>\n                        <div class=\"analysis-block\">\n                            <h4>Multi-Agent Code Generation</h4>\n                            <div class=\"analysis-item\">\n                                <h5>Evolution of Approaches</h5>\n                                <ul>\n                                    <li><strong>Role-Based:</strong> Fixed roles (planner, coder, tester)</li>\n                                    <li><strong>Hierarchical:</strong> High-level planning + low-level execution</li>\n                                    <li><strong>Adaptive:</strong> Dynamic role assignment based on task complexity</li>\n                                    <li><strong>Collaborative:</strong> Shared memory and iterative refinement</li>\n                                </ul>\n                            </div>\n                        </div>\n                    </div>"
}