{
  "page": 45,
  "title": "Planning and Tool-Use in Math/Code",
  "content": "<div class=\"article-header\">\n                        <div class=\"section-label\">Section 6.1.1 &middot; Foundational Reasoning</div>\n                        <h1>Planning and Tool-Use in Mathematics and Code</h1>\n                    </div>\n                    <div class=\"original-content\">\n                        <h3>Planning in Mathematics</h3>\n                        <p>Trinh et al. [29] solves Olympiad-level geometry problems by decomposing them into sequential stages of construction, lemma generation, and verification, yielding a structured multi-step process that resembles a planned reasoning trajectory. Program-search approaches [30] iteratively refine candidate programs and mathematical structures, a procedure that naturally forms a coarse-to-fine exploration path.</p>\n                        <p>Large-scale exploration frameworks [461, 460] also operate through cycles of proposing, testing, and modifying conjectures or geometric objects, which collectively create a procedural structure aligned with planning. Efforts toward more robust mathematical reasoning [459] similarly rely on stepwise reasoning patterns, further reinforcing the presence of implicit planning dynamics.</p>\n                        <h3>Planning in Code Agents</h3>\n                        <p>In code agents, planning has likewise emerged as an essential component for organizing multi-step reasoning and enabling more structured decision-making. Early systems such as CodeChain [464] and CodeAct [99] introduce explicit planning or action spaces to support modular code construction, while KareCoder [465] integrate external knowledge sources or domain-specific information into the planning process.</p>\n                        <h3>Tool-Use</h3>\n                        <p>Integrating external computational tools with LLMs has become a central mechanism for extending the reasoning and generation capabilities of single-agent systems. A defining characteristic of many mathematical reasoning systems is their integration with external computational tools. Formal theorem-proving agents such as Thakur et al. [473] operate directly within the Lean proof assistant, selecting tactics and interacting with the underlying prover through in-context guidance.</p>\n                        <p>In code agents, external tools have similarly become crucial for extending the capabilities of LLM-based agents beyond pure text generation. Early work such as Toolformer [6] and ToolCoder [477] explored how models can learn to invoke APIs or search tools to obtain missing information during generation.</p>\n                    </div>\n                    <div class=\"analysis-section\">\n                        <h3>Analysis & Explanation</h3>\n                        <div class=\"analysis-block\">\n                            <h4>Tool Integration Patterns</h4>\n                            <div class=\"analysis-item\">\n                                <h5>External Tool Categories</h5>\n                                <ul>\n                                    <li><strong>Theorem Provers:</strong> Lean, Coq for formal verification</li>\n                                    <li><strong>Symbolic Systems:</strong> Computer algebra, satisfiability solvers</li>\n                                    <li><strong>Code Execution:</strong> Runtime feedback, test execution</li>\n                                    <li><strong>Search APIs:</strong> Documentation, code repositories</li>\n                                </ul>\n                            </div>\n                        </div>\n                    </div>"
}